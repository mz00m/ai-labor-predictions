/**
 * Reads a weekly digest JSON and prints a Markdown summary to stdout.
 * Used by the GitHub Actions workflow to populate the PR body.
 *
 * Usage: npx tsx scripts/digest-summary.ts src/data/digests/2026-W09.json
 */

import fs from "fs";
import { WeeklyDigest } from "../src/lib/types/digest";

const digestPath = process.argv[2];
if (!digestPath || !fs.existsSync(digestPath)) {
  console.error("Usage: npx tsx scripts/digest-summary.ts <digest.json>");
  process.exit(1);
}

const digest: WeeklyDigest = JSON.parse(fs.readFileSync(digestPath, "utf-8"));

const lines: string[] = [];

// Header
lines.push(`## Weekly Research Digest: ${digest.weekId}`);
lines.push("");
lines.push(`**${digest.dateRange.from}** to **${digest.dateRange.to}** | ${digest.papers.length} papers selected from ${digest.totalPapersDiscovered} discovered`);
lines.push("");

// Suggested data points â€” the most important section
const dataPoints = digest.suggestedDataPoints || [];
if (dataPoints.length > 0) {
  lines.push(`### Suggested Data Points (${dataPoints.length})`);
  lines.push("");
  lines.push("| Prediction | Value | Source | Confidence |");
  lines.push("|:-----------|------:|:-------|:----------:|");
  for (const dp of dataPoints) {
    const excerpt = dp.excerpt.length > 80 ? dp.excerpt.slice(0, 77) + "..." : dp.excerpt;
    const conf = dp.confidence === "high" ? "ðŸŸ¢" : dp.confidence === "medium" ? "ðŸŸ¡" : "ðŸ”´";
    lines.push(`| ${dp.predictionSlug} | **${dp.value} ${dp.unit}** | [${dp.sourceTitle.slice(0, 50)}](${dp.sourceUrl}) | ${conf} ${dp.confidence} |`);
  }
  lines.push("");
  for (const dp of dataPoints) {
    lines.push(`> **${dp.predictionSlug}**: "${dp.excerpt}"`);
    lines.push("");
  }
} else {
  lines.push("### Suggested Data Points");
  lines.push("");
  lines.push("_No quantitative data points extracted this week._");
  lines.push("");
}

// Top papers
lines.push("### Top 10 Papers");
lines.push("");
for (const p of digest.papers.slice(0, 10)) {
  const tier = `T${p.classifiedTier}`;
  const predictions = p.linkedPredictions.map((lp) => lp.slug).join(", ");
  const predLabel = predictions ? ` â†’ ${predictions}` : "";
  lines.push(`1. **[${p.title.slice(0, 100)}](${p.url})** (${tier}, ${p.source}, score: ${p.compositeScore})${predLabel}`);
}
lines.push("");

// Category breakdown
const cats = digest.byCategory;
lines.push("### By Category");
lines.push("");
lines.push(`| Category | Count |`);
lines.push(`|:---------|------:|`);
lines.push(`| Displacement | ${cats.displacement.length} |`);
lines.push(`| Wages | ${cats.wages.length} |`);
lines.push(`| Adoption | ${cats.adoption.length} |`);
lines.push(`| Signals | ${cats.signals.length} |`);
lines.push(`| Unlinked | ${cats.unlinked.length} |`);
lines.push("");

// Sources
lines.push("### Sources");
lines.push("");
const sources = Object.entries(digest.stats.bySource).sort(([, a], [, b]) => b - a);
lines.push(sources.map(([src, count]) => `${src}: ${count}`).join(" | "));
lines.push("");

// Footer
lines.push("---");
lines.push("Merge to accept this digest, or close to discard. _Generated by GitHub Actions._");

console.log(lines.join("\n"));
